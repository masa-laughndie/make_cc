# memo

## プロセッサのスタイル

CISC(シスク) ... x86-64 で採用されているスタイル

- 機械語の演算がレジスタだけでなくメモリアドレスを取ることも可能。
- 機械語命令の長さが可変長。
- 複雑な操作を１命令で行う命令を多く備えている

=> RISC に対して生き残っているのは、Intel によって CPU の命令デコーダで x86 命令を内部的に暑署の RISC 命令に変換して、RISC プロセッサ化しているから。  
 => RISC と同様に高層化が可能になった

RISC(リスク) ... x86-64 以外の主要プロセッサはほぼ全てこちら

- 演算はレジスタ間でのみを行う
- メモリに対する操作はレジスタへのロードとレジスタからのストアのみ
- 機械語命令の長さは統一的
- 複合命令がなく、簡単な命令のみを備えている

=> 単純ゆえに高層化しやすい

## x86-64 のレジスタマシンでのスタックマシンの実現方法

四則演算を行う際には加減算と同じ方法でアセンブリ変換できない。
理由は加減算はコンパイルする際に RAX を結果のレジスタとして、そこの値を用いて演算を行い、さらに更新しつつ、という感じに中間結果を１つだけを保持し順々に演算していけば良かった。
=> ex: 2+3+4 -> 5 -> 9
しかし、四則演算の場合は、中間結果が複数必要となり、１つでは対応できないからである。
=> ex: 2*3+4*5 -> 6(=2*3), 20(=4*5) -> 26

そこで、スタックマシン的な振る舞いを用いて複数の中間結果を保持する必要がある。
x86-64 はレジスタマシンであるが、メモリにスタックして保持したものをレジスタマシンで演算を行い、
またメモリのスタック領域に保持(push)することでこれが可能となる。
方法としては以下の通り。

- スタックの先頭を指すレジスタを１つ用意(スタックポインタ)
- メモリにプッシュされた値をプップしてきて、演算を行い、スタックポインタの値を変更しつつ、またスタックに書き込む

例

```
// 左辺と右辺をスタックにプッシュ
push 1
push 2

// レジスタプップしてきて、演算を行う
pop rdi
pop rax
add rax, rdi

// 結果をスタックにプッシュ
push rax
```

## 分割コンパイル

=> １つのプログラムを複数のソースファイルに分割して書き、別々にコンパイルすること。

オブジェクトファイル ... 単体では実行不可能なプログラムの断片の入ったファイル
実行ファイル ... オブジェクトファイル郡をまとめた実行可能なファイル
リンカ ... オブジェクトファイル郡をまとめて実行ファイルにするプログラム

分割コンパイルをしなければならない必然性(ex: そうしないと実行できない等)は無いが多くの面で利点がある

分割コンパイルをすべき理由

- 分割しない場合、１箇所を変更しただけでファイル全てをコンパイルし直す必要が出る  
  => 開発サイクルが回しにくくなる
- 単純に人間にとって管理がしにくくなる  
  => 機能ごとに分割した方が、それぞれのファイルがどんな処理をしているかわかりやすく、変更等加えやすくなる

そもそも、標準ライブラリもオブジェクトファイルなので、標準ライブラリの関数(ex: printf)を使っている場合は実は分割コンパイルしている。
