# memo

## アセンブリ言語

### 用語

- ニーモニック(アセンブリコード) ... アセンブリ言語の１つ１つの命令
- オペコード(オペレーションコード) ... ニーモニックの先頭の命令
- オペランド ... オペコードがとる引数

(ex)
mov rax, rsi
=> mov ... オペコード
=> rax, rsi ... オペランド
=> ひとかたまりでニーモニック(アセンブラコード)

### よく使われるオペコードの種類

- mov ... 第 1 引数に第 2 引数を代入
  - mov rax, rsi => rax = rsi
- add ... 第 1 引数に第 1 引数と第 2 引数の加算結果を代入
  - add rax, rsi => rax = rax + rsi
- sub ... add の減算版
- push ... スタックメモリに値を積む
  - push rax => rax の値をスタックのトップにプッシュ(push 1 とかでも良い)
- pop ... スタックメモリのトップから値を取得する
  - pop rax => スタックのトップの値を取得して rax に代入
- call ... 関数を呼び出す
  - 内部的には「call 命令の次のアドレスを push(呼び出した関数から戻る場所を記憶) => 呼び出し関数のアドレスに jmp」
- ret ... 呼び出し関数から call もとに戻る
  - 内部的には「pop して戻り先のアドレスを取得 => 取得したアドレスに jmp」

## プロセッサのスタイル

CISC(シスク) ... x86-64 で採用されているスタイル

- 機械語の演算がレジスタだけでなくメモリアドレスを取ることも可能。
- 機械語命令の長さが可変長。
- 複雑な操作を１命令で行う命令を多く備えている

=> RISC に対して生き残っているのは、Intel によって CPU の命令デコーダで x86 命令を内部的に暑署の RISC 命令に変換して、RISC プロセッサ化しているから。  
 => RISC と同様に高層化が可能になった

RISC(リスク) ... x86-64 以外の主要プロセッサはほぼ全てこちら

- 演算はレジスタ間でのみを行う
- メモリに対する操作はレジスタへのロードとレジスタからのストアのみ
- 機械語命令の長さは統一的
- 複合命令がなく、簡単な命令のみを備えている

=> 単純ゆえに高層化しやすい

## x86-64 のレジスタマシンでのスタックマシンの実現方法

四則演算を行う際には加減算と同じ方法でアセンブリ変換できない。
理由は加減算はコンパイルする際に RAX を結果のレジスタとして、そこの値を用いて演算を行い、さらに更新しつつ、という感じに中間結果を１つだけを保持し順々に演算していけば良かった。
=> ex: 2+3+4 -> 5 -> 9
しかし、四則演算の場合は、中間結果が複数必要となり、１つでは対応できないからである。
=> ex: 2*3+4*5 -> 6(=2*3), 20(=4*5) -> 26

そこで、スタックマシン的な振る舞いを用いて複数の中間結果を保持する必要がある。
x86-64 はレジスタマシンであるが、メモリにスタックして保持したものをレジスタマシンで演算を行い、
またメモリのスタック領域に保持(push)することでこれが可能となる。
方法としては以下の通り。

- スタックの先頭を指すレジスタを１つ用意(スタックポインタ)
- メモリにプッシュされた値をプップしてきて、演算を行い、スタックポインタの値を変更しつつ、またスタックに書き込む

例

```
// 左辺と右辺をスタックにプッシュ
push 1
push 2

// レジスタプップしてきて、演算を行う
pop rdi
pop rax
add rax, rdi

// 結果をスタックにプッシュ
push rax
```

## 分割コンパイル

=> １つのプログラムを複数のソースファイルに分割して書き、別々にコンパイルすること。

オブジェクトファイル ... 単体では実行不可能なプログラムの断片の入ったファイル
実行ファイル ... オブジェクトファイル郡をまとめた実行可能なファイル
リンカ ... オブジェクトファイル郡をまとめて実行ファイルにするプログラム

分割コンパイルをしなければならない必然性(ex: そうしないと実行できない等)は無いが多くの面で利点がある

分割コンパイルをすべき理由

- 分割しない場合、１箇所を変更しただけでファイル全てをコンパイルし直す必要が出る  
  => 開発サイクルが回しにくくなる
- 単純に人間にとって管理がしにくくなる  
  => 機能ごとに分割した方が、それぞれのファイルがどんな処理をしているかわかりやすく、変更等加えやすくなる

そもそも、標準ライブラリもオブジェクトファイルなので、標準ライブラリの関数(ex: printf)を使っている場合は実は分割コンパイルしている。

## 関数呼び出し時の内部のローカル変数の保持方法

関数呼び出し時には呼び出した関数の処理が終了した後に元の呼び出し側に戻る必要がある。
その元の呼び出し側のアドレスを**リターンアドレス**と呼ぶ(call 時の push したアドレス)。メモリの上のスタックに保存される。
=> 仮に関数呼び出しが一段ならリターンアドレスは適当なレジスタに保存しておけ良いが、関数呼び出しはいくらでも深くできるので、メモリに保存する必要がある

関数フレーム(アクティベーションレコード) ... 関数呼び出しごとに確保されるメモリ領域
ベースレジスタ ... 現在の関数フレームの開始位置を常に指しているレジスタ
ベースポインタ ... ベースレジスタに入ってる値

プロローグ ... コンパイラが関数の先頭に出力する定型の命令

```
push rbp
mov rbp, rsp
sub rsp, 16 <= 16は変数の個数やサイズによる
```

エピローグ ... コンパイラが関数の末尾に出力する定型の命令

```
mov rsp, rbp
pop rbp
ret
```

## レジスタ整理

- RAX ... 最終的な返り値を格納する(main における ret は rax の値を返す)
- RDI ... 第 1 引数
- RSI ... 第 2 引数
- RBP ... ベースレジスタ(関数フレームの開始位置)

## アセンブラ命令
